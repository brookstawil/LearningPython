

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Some Tips, Tricks, and Common Errors &mdash; How to Think Like a Computer Scientist: Learning with Python 3</title>
    
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3rd Edition',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="How to Think Like a Computer Scientist: Learning with Python 3" href="index.html" />
    <link rel="prev" title="An odds-and-ends Workbook" href="app_b.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="app_b.html" title="An odds-and-ends Workbook"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">How to Think Like a Computer Scientist: Learning with Python 3</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="some-tips-tricks-and-common-errors">
<h1>Some Tips, Tricks, and Common Errors<a class="headerlink" href="#some-tips-tricks-and-common-errors" title="Permalink to this headline">¶</a></h1>
<p>These are small summaries of ideas, tips, and commonly seen errors that might be
helpful to those beginning Python.</p>
<div class="section" id="functions">
<span id="index-0"></span><h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>Functions help us with our mental chunking: they allow us to group together statements
for a high-level purpose, e.g. a function to sort a list of items, a function to make
the turtle draw a spiral, or a function to compute the mean and standard deviation of some
measurements.</p>
<p>There are two kinds of functions: fruitful, or value-returning functions, which <em>calculate and return a value</em>, and we use them
because we&#8217;re primarily interested in the value they&#8217;ll return.  Void (non-fruitful) functions
are used because they <em>perform actions</em> that we want done &#8212; e.g. make a turtle draw a rectangle, or
print the first thousand prime numbers.  They always return <tt class="docutils literal"><span class="pre">None</span></tt> &#8212; a special dummy value.</p>
<div class="admonition-tip-none-is-not-a-string admonition">
<p class="first admonition-title">Tip: <tt class="docutils literal"><span class="pre">None</span></tt> is not a string</p>
<p class="last">Values like <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">True</span></tt> and <tt class="docutils literal"><span class="pre">False</span></tt> are not strings: they are special values
in Python, and are in the list of keywords we gave in chapter 2 (Variables, expressions, and statements).  Keywords are special
in the language: they are part of the syntax. So we cannot create our own
variable or function with a name <tt class="docutils literal"><span class="pre">True</span></tt> &#8212; we&#8217;ll get a syntax error.
(Built-in functions are not privileged like keywords: we can define our own
variable or function called <tt class="docutils literal"><span class="pre">len</span></tt>, but we&#8217;d be silly to do so!)</p>
</div>
<p>Along with the fruitful/void families of functions, there are two flavors of the
<tt class="docutils literal"><span class="pre">return</span></tt> statement in Python: one that returns
a useful value, and the other that returns nothing, or <tt class="docutils literal"><span class="pre">None</span></tt>.   And if we get to the end of
any function and we have not explicitly executed any <tt class="docutils literal"><span class="pre">return</span></tt> statement, Python automatically
returns the value <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
<div class="admonition-tip-understand-what-the-function-needs-to-return admonition">
<p class="first admonition-title">Tip: Understand what the function needs to return</p>
<p class="last">Perhaps nothing &#8212; some functions exists purely to perform actions rather than to
calculate and return a result.  But if the function should return a value, make sure
all execution paths do return the value.</p>
</div>
<p>To make functions more useful, they are given <em>parameters</em>.  So a function to make a turtle draw
a square might have two parameters &#8212; one for the turtle that needs to do the drawing, and another
for the size of the square.  See the first example in Chapter 4 (Functions) &#8212; that function can be used with any turtle,
and for any size square.  So it is much more general than a function that always uses a specific turtle,
say <tt class="docutils literal"><span class="pre">tess</span></tt> to draw a square of a specific size, say 30.</p>
<div class="admonition-tip-use-parameters-to-generalize-functions admonition">
<p class="first admonition-title">Tip: Use parameters to generalize functions</p>
<p class="last">Understand which parts of the function will be hard-coded and unchangeable, and which parts
should become parameters so that they can be customized by the caller of the function.</p>
</div>
<div class="admonition-tip-try-to-relate-python-functions-to-ideas-we-already-know admonition">
<p class="first admonition-title">Tip: Try to relate Python functions to ideas we already know</p>
<p class="last">In math, we&#8217;re familiar with functions like  <tt class="docutils literal"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">3x</span> <span class="pre">+</span> <span class="pre">5</span></tt>.  We already understand
that when we call the function <tt class="docutils literal"><span class="pre">f(3)</span></tt> we make some association between the parameter x
and the argument 3. Try to draw parallels to argument passing in Python.</p>
</div>
<p>Quiz:  Is the function <tt class="docutils literal"><span class="pre">f(z)</span> <span class="pre">=</span> <span class="pre">3z</span> <span class="pre">+</span> <span class="pre">5</span></tt> the same as function <tt class="docutils literal"><span class="pre">f</span></tt> above?</p>
<div class="section" id="problems-with-logic-and-flow-of-control">
<span id="index-1"></span><h3>Problems with logic and flow of control<a class="headerlink" href="#problems-with-logic-and-flow-of-control" title="Permalink to this headline">¶</a></h3>
<p>We often want to know if some condition holds for any item in a list, e.g. &#8220;does the list have any odd numbers?&#8221;
This is a common mistake:</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">any_odd</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>  <span class="c"># Buggy version</span>
    <span class="sd">&quot;&quot;&quot; Return True if there is an odd number in xs, a list of integers. &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
       <span class="k">if</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
           <span class="k">return</span> <span class="k">True</span>
       <span class="k">else</span><span class="p">:</span>
           <span class="k">return</span> <span class="k">False</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Can we spot two problems here?  As soon as we execute a <tt class="docutils literal"><span class="pre">return</span></tt>, we&#8217;ll leave the function.
So the logic of saying &#8220;If I find an odd number I can return <tt class="docutils literal"><span class="pre">True</span></tt>&#8221; is fine.  However, we cannot
return <tt class="docutils literal"><span class="pre">False</span></tt> after only looking at one item &#8212; we can only return <tt class="docutils literal"><span class="pre">False</span></tt> if we&#8217;ve been through
all the items, and none of them are odd.  So line 6 should not be there, and line 7 has to be
outside the loop.  To find the second problem above, consider what happens if you call this function
with an argument that is an empty list.  Here is a corrected version:</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">any_odd</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return True if there is an odd number in xs, a list of integers. &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
       <span class="k">if</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
           <span class="k">return</span> <span class="k">True</span>
    <span class="k">return</span> <span class="k">False</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>This &#8220;eureka&#8221;, or &#8220;short-circuit&#8221; style of returning from a function as
soon as we are certain what the outcome will be
was first seen in Section 8.10, in the chapter on strings.</p>
<p>It is preferred over this one, which also works correctly:</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">any_odd</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return True if there is an odd number in xs, a list of integers. &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
       <span class="k">if</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>    <span class="c"># Count the odd numbers</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
       <span class="k">return</span> <span class="k">True</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="k">False</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The performance disadvantage of this one is that it traverses the whole list,
even if it knows the outcome very early on.</p>
<div class="admonition-tip-think-about-the-return-conditions-of-the-function admonition">
<p class="first admonition-title">Tip: Think about the return conditions of the function</p>
<p class="last">Do I need to look at all elements in all cases?  Can I shortcut and take an
early exit?  Under what conditions?  When will I have to examine all the items
in the list?</p>
</div>
<p>The code in lines 7-10 can also be tightened up.  The expression <tt class="docutils literal"><span class="pre">count</span> <span class="pre">&gt;</span> <span class="pre">0</span></tt>
evaluates to a Boolean value, either <tt class="docutils literal"><span class="pre">True</span></tt> or <tt class="docutils literal"><span class="pre">False</span></tt>.  The value can be used
directly in the <tt class="docutils literal"><span class="pre">return</span></tt> statement.   So we could cut out that code and simply
have the following:</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">def</span> <span class="nf">any_odd</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return True if there is an odd number in xs, a list of integers. &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
       <span class="k">if</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>   <span class="c"># Count the odd numbers</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>   <span class="c"># Aha! a programmer who understands that Boolean</span>
                       <span class="c">#   expressions are not just used in if statements!</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Although this code is tighter, it is not as nice as the one that did the short-circuit
return as soon as the first odd number was found.</p>
<div class="admonition-tip-generalize-your-use-of-booleans admonition">
<p class="first admonition-title">Tip: Generalize your use of Booleans</p>
<p class="last">Mature programmers won&#8217;t write <tt class="docutils literal"><span class="pre">if</span> <span class="pre">is_prime(n)</span> <span class="pre">==</span> <span class="pre">True:</span></tt> when they could
say instead   <tt class="docutils literal"><span class="pre">if</span> <span class="pre">is_prime(n):</span></tt>    Think more generally about Boolean values,
not just in the context of <tt class="docutils literal"><span class="pre">if</span></tt> or <tt class="docutils literal"><span class="pre">while</span></tt> statements.  Like arithmetic
expressions, they have their own set of operators (<tt class="docutils literal"><span class="pre">and</span></tt>, <tt class="docutils literal"><span class="pre">or</span></tt>, <tt class="docutils literal"><span class="pre">not</span></tt>) and
values (<tt class="docutils literal"><span class="pre">True</span></tt>, <tt class="docutils literal"><span class="pre">False</span></tt>) and can be assigned to variables, put into lists, etc.
A good resource for improving your use of Booleans is
<a class="reference external" href="http://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/Boolean_Expressions">http://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/Boolean_Expressions</a></p>
</div>
<p>Exercise time:</p>
<ul class="simple">
<li>How would we adapt this to make another function which returns <tt class="docutils literal"><span class="pre">True</span></tt> if <em>all</em> the numbers are odd?
Can you still use a short-circuit style?</li>
<li>How would we adapt it to return <tt class="docutils literal"><span class="pre">True</span></tt> if at least three of the numbers are odd?  Short-circuit the traversal
when the third odd number is found &#8212; don&#8217;t traverse the whole list unless we have to.</li>
</ul>
</div>
<div class="section" id="local-variables">
<span id="index-2"></span><h3>Local variables<a class="headerlink" href="#local-variables" title="Permalink to this headline">¶</a></h3>
<p>Functions are called, or activated, and while they&#8217;re busy they create their own stack frame which holds local
variables.  A local variable is one that belongs to the current activation.  As soon as the function returns
(whether from an explicit return statement or because Python reached the last statement), the stack frame
and its local variables are all destroyed.  The important consequence of this is that a function cannot use
its own variables to remember any kind of state between different activations.  It cannot count how many
times it has been called, or remember to switch colors between red and blue UNLESS it makes use of variables
that are global.  Global variables will survive even after our function has exited, so they are the
correct way maintain information between calls.</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">sz</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">def</span> <span class="nf">h2</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Draw the next step of a spiral on each call. &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">sz</span>
    <span class="n">tess</span><span class="o">.</span><span class="n">turn</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">tess</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span>
    <span class="n">sz</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>This fragment assumes our turtle is <tt class="docutils literal"><span class="pre">tess</span></tt>.  Each time we call <tt class="docutils literal"><span class="pre">h2()</span></tt> it turns, draws, and increases
the global variable <tt class="docutils literal"><span class="pre">sz</span></tt>.  Python always assumes that an assignment to a variable (as in line 7) means
that we want a new local variable, unless we&#8217;ve provided a <tt class="docutils literal"><span class="pre">global</span></tt> declaration (on line 4).  So
leaving out the global declaration means this does not work.</p>
<div class="admonition-tip-local-variables-do-not-survive-when-you-exit-the-function admonition">
<p class="first admonition-title">Tip: Local variables do not survive when you exit the function</p>
<p class="last">Use a Python visualizer like the one at <a class="reference external" href="http://netserv.ict.ru.ac.za/python3_viz">http://netserv.ict.ru.ac.za/python3_viz</a> to build a
strong understanding of function calls, stack frames, local variables, and function returns.</p>
</div>
<div class="admonition-tip-assignment-in-a-function-creates-a-local-variable admonition">
<p class="first admonition-title">Tip: Assignment in a function creates a local variable</p>
<p class="last">Any assignment to a variable within a function means Python will make a local variable,
unless we override with <tt class="docutils literal"><span class="pre">global</span></tt>.</p>
</div>
</div>
<div class="section" id="event-handler-functions">
<span id="index-3"></span><h3>Event handler functions<a class="headerlink" href="#event-handler-functions" title="Permalink to this headline">¶</a></h3>
<p>Our chapter on event handling showed three different kinds of events that we could handle.
They each have their own subtle points that can trip us up.</p>
<ul class="simple">
<li>Event handlers are void functions &#8212; they don&#8217;t return any values.</li>
<li>They&#8217;re automatically called by the Python interpreter in response to an event,
so we don&#8217;t get to see the code that calls them.</li>
<li>A mouse-click event passes two coordinate arguments to its handler, so when we write this handler
we have to provide for two parameters (usually named <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt>).
This is how the handler knows where the mouse click occurred.</li>
<li>A keypress event handler has to be bound to the key it responds to.  There is a messy extra step
when using keypresses: we have to remember to issue a <tt class="docutils literal"><span class="pre">wn.listen()</span></tt> before our program will
receive any keypresses.  But if the user presses the key 10 times, the handler will be called ten times.</li>
<li>Using a timer to create a future-dated event only causes one call to the handler.  If we want
repeated periodic handler activations, then from within the handler we
call <tt class="docutils literal"><span class="pre">wn.ontimer(....)</span></tt> to set up the next event.</li>
</ul>
</div>
</div>
<div class="section" id="string-handling">
<span id="index-4"></span><h2>String handling<a class="headerlink" href="#string-handling" title="Permalink to this headline">¶</a></h2>
<p>There are only four <em>really</em> important operations on strings, and we&#8217;ll be able to do
just about anything.  There are many more nice-to-have methods
(we&#8217;ll call them sugar coating)
that can make life easier, but if we can work with the basic four operations
smoothly, we&#8217;ll have a great grounding.</p>
<ul class="simple">
<li>len(str)  finds the length of a string.</li>
<li>str[i]    the subscript operation extracts the i&#8217;th character of the string, as a new string.</li>
<li>str[i:j]  the slice operation extracts a substring out of a string.</li>
<li>str.find(target) returns the index where target occurs within the string, or -1 if it is not found.</li>
</ul>
<p>So if we need to know if &#8220;snake&#8221; occurs as a substring within <tt class="docutils literal"><span class="pre">s</span></tt>, we could write</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;snake&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="o">...</span>
<span class="k">if</span> <span class="s">&quot;snake&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span> <span class="o">...</span>           <span class="c"># Also works, nice-to-know sugar coating!</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>It would be wrong to split the string into words unless we were asked whether the <em>word</em> &#8220;snake&#8221;
occurred in the string.</p>
<p>Suppose we&#8217;re asked to read some lines of data and find function definitions, e.g.: <tt class="docutils literal"><span class="pre">def</span> <span class="pre">some_function_name(x,</span> <span class="pre">y):</span></tt>,
and we are further asked to isolate and work with the name of the function. (Let&#8217;s say, print it.)</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="s">&quot;...&quot;</span>                         <span class="c"># Get the next line from somehwere</span>
<span class="n">def_pos</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;def &quot;</span><span class="p">)</span>          <span class="c"># Look for &quot;def &quot; in the line</span>
<span class="k">if</span> <span class="n">def_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                  <span class="c"># If it occurs at the left margin</span>
  <span class="n">op_index</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">)</span>          <span class="c"># Find the index of the open parenthesis</span>
  <span class="n">fnname</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="n">op_index</span><span class="p">]</span>          <span class="c"># Slice out the function name</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">fnname</span><span class="p">)</span>                   <span class="c"># ... and work with it.</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>One can extend these ideas:</p>
<ul class="simple">
<li>What if the function def was indented, and didn&#8217;t start at column 0?
The code would need a bit of adjustment, and we&#8217;d probably want to be sure that
all the characters in front of the <tt class="docutils literal"><span class="pre">def_pos</span></tt> position were spaces. We would not want to
do the wrong thing on data like this:  <tt class="docutils literal"><span class="pre">#</span> <span class="pre">I</span> <span class="pre">def</span> <span class="pre">initely</span> <span class="pre">like</span> <span class="pre">Python!</span></tt></li>
<li>We&#8217;ve assumed on line 3 that we will find an open parenthesis.  It may need to
be checked that we did!</li>
<li>We have also assumed that there was exactly one space between the keyword <tt class="docutils literal"><span class="pre">def</span></tt> and
the start of the function name.  It will not work nicely for <tt class="docutils literal"><span class="pre">def</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="pre">f(x)</span></tt></li>
</ul>
<p>As we&#8217;ve already mentioned, there are many more &#8220;sugar-coated&#8221; methods that let us
work more easily with strings.  There is an <tt class="docutils literal"><span class="pre">rfind</span></tt> method, like <tt class="docutils literal"><span class="pre">find</span></tt>, that searches from the
end of the string backwards.  It is useful if we want to find the last occurrence of something.
The <tt class="docutils literal"><span class="pre">lower</span></tt> and <tt class="docutils literal"><span class="pre">upper</span></tt> methods can do case conversion.  And the <tt class="docutils literal"><span class="pre">split</span></tt> method is great for
breaking a string into a list of words, or into a list of lines.  We&#8217;ve also made extensive use
in this book of the <tt class="docutils literal"><span class="pre">format</span></tt> method. In fact, if we want to
practice reading the Python documentation and learning some new methods on our own, the
string methods are an excellent resource.</p>
<p>Exercises:</p>
<ul class="simple">
<li>Suppose any line of text can contain at most one url that starts with &#8220;<a class="reference external" href="http://">http://</a>&#8221;
and ends at the next space in the line.  Write a fragment of code to
extract and print the full url if it is present.  (Hint: read the documentation
for <tt class="docutils literal"><span class="pre">find</span></tt>.  It takes some extra arguments, so you can set a starting point
from which it will search.)</li>
<li>Suppose a string contains at most one substring &#8220;&lt; ... &gt;&#8221;.  Write a fragment of code to
extract and print the portion of the string between the angle brackets.</li>
</ul>
</div>
<div class="section" id="looping-and-lists">
<h2>Looping and lists<a class="headerlink" href="#looping-and-lists" title="Permalink to this headline">¶</a></h2>
<p>Computers are useful because they can repeat computation, accurately and fast.
So loops are going to be a central feature of almost all programs you encounter.</p>
<div class="admonition-tip-don-t-create-unnecessary-lists admonition">
<p class="first admonition-title">Tip: Don&#8217;t create unnecessary lists</p>
<p class="last">Lists are useful if you need to keep data for later computation.  But if you
don&#8217;t need lists, it is probably better not to generate them.</p>
</div>
<p>Here are two functions that both generate ten million random numbers, and return
the sum of the numbers.  They both work.</p>
<blockquote>
<div><div class="highlight-python3"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="n">joe</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">sum1</span><span class="p">():</span>
   <span class="sd">&quot;&quot;&quot; Build a list of random numbers, then sum them &quot;&quot;&quot;</span>
   <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000000</span><span class="p">):</span>
       <span class="n">num</span> <span class="o">=</span> <span class="n">joe</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>  <span class="c"># Generate one random number</span>
       <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>             <span class="c"># Save it in our list</span>

   <span class="n">tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tot</span>

<span class="k">def</span> <span class="nf">sum2</span><span class="p">():</span>
   <span class="sd">&quot;&quot;&quot; Sum the random numbers as we generate them &quot;&quot;&quot;</span>
   <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000000</span><span class="p">):</span>
       <span class="n">num</span> <span class="o">=</span> <span class="n">joe</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
       <span class="n">tot</span> <span class="o">+=</span> <span class="n">num</span>
   <span class="k">return</span> <span class="n">tot</span>

<span class="nb">print</span><span class="p">(</span><span class="n">sum1</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sum2</span><span class="p">())</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>What reasons are there for preferring the second version here?
(Hint: open a tool like the Performance Monitor on your computer, and watch the memory
usage. How big can you make the list before you get a fatal memory error in <tt class="docutils literal"><span class="pre">sum1</span></tt>?)</p>
<p>In a similar way, when working with files, we often have an option to read the whole file
contents into a single string, or we can read one line at a time and process
each line as we read it. Line-at-a-time is the more traditional and perhaps
safer way to do things &#8212; you&#8217;ll be able to work comfortably no matter how
large the file is. (And, of course, this mode of processing the files was
essential in the old days when computer memories were much smaller.)
But you may find whole-file-at-once is sometimes more convenient!</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="app_b.html" title="An odds-and-ends Workbook"
             >previous</a> |</li>
        <li><a href="index.html">How to Think Like a Computer Scientist: Learning with Python 3</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>